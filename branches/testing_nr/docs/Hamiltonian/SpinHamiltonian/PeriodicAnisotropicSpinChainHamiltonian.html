<html>
  <head>
    <title>PeriodicAnisotropicSpinChainHamiltonian</title>
  </head>

  <body>
    <H1><DIV align=center>Class : PeriodicAnisotropicSpinChainHamiltonian</DIV></H1>

<DIV ALIGN="CENTER">class deriving from <A HREF="/home/regnault/development/Physics/DiagHam/docs/Hamiltonian/AbstractHamiltonian.html">AbstractHamiltonian</A></DIV><BR>
<H3>PeriodicAnisotropicSpinChainHamiltonian :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Hamiltonian/SpinHamiltonian/PeriodicAnisotropicSpinChainHamiltonian.html">PeriodicAnisotropicSpinChainHamiltonian</A>  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/SpinHilbertSpace/AbstractSpinChain.html">AbstractSpinChain</A>* , int , double* ,  double* , double* , double* , double* , double* , 
  double* , double* , double* szFactor )<BR><BR>
<u>description:</u>constructor from default datas 
<BR><BR><BR>
<u>input parameters:</u>
<BR>chain = pointer to Hilbert space of the associated system 
<BR>nbrSpin = number of spin 
<BR>jxx = array containing Jxx coupling constants between spins 
<BR>jyy = array containing Jyy coupling constants between spins 
<BR>jzz = array containing Jzz coupling constants between spins 
<BR>jxy = array containing Jxy coupling constants between spins 
<BR>jxz = array containing Jxz coupling constants between spins 
<BR>jyz = array containing Jyz coupling constants between spins 
<BR>sxFactor = array containing factors in front of Sx term (g mu B) 
<BR>syFactor = array containing factors in front of Sy term (g mu B) 
<BR>szFactor = array containing factors in front of Sz term (g mu B) 
<BR>
<BR><BR><BR><H3>~PeriodicAnisotropicSpinChainHamiltonian :</H3>
<u>prototype:</u>     ~PeriodicAnisotropicSpinChainHamiltonian  ()<BR><BR>
<u>description:</u>destructor 
<BR>
<BR><BR><BR><H3>Clone :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Hamiltonian/AbstractHamiltonian.html">AbstractHamiltonian</A>* Clone  ()<BR><BR>
<u>description:</u>clone hamiltonian without duplicating datas 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> pointer to cloned hamiltonian 
<BR>
<BR><BR><BR><H3>SetChain :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Hamiltonian/SpinHamiltonian/PeriodicAnisotropicSpinChainHamiltonian.html">PeriodicAnisotropicSpinChainHamiltonian</A>& SetChain  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/SpinHilbertSpace/AbstractSpinChain.html">AbstractSpinChain</A>* chain )<BR><BR>
<u>description:</u>set chain 
<BR><BR><BR>
<u>input parameters:</u>
<BR>chain = pointer on Hilbert space of the associated system 
<BR><BR><BR>
<u>return value:</u> reference on current Hamiltonian 
<BR>
<BR><BR><BR><H3>SetHilbertSpace :</H3>
<u>prototype:</u>     void SetHilbertSpace  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/AbstractHilbertSpace.html">AbstractHilbertSpace</A>* hilbertSpace )<BR><BR>
<u>description:</u>set Hilbert space 
<BR><BR><BR>
<u>input parameters:</u>
<BR>hilbertSpace = pointer to Hilbert space to use 
<BR>
<BR><BR><BR><H3>GetHilbertSpace :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/AbstractHilbertSpace.html">AbstractHilbertSpace</A>* GetHilbertSpace  ()<BR><BR>
<u>description:</u>get Hilbert space on which Hamiltonian acts 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> pointer to used Hilbert space 
<BR>
<BR><BR><BR><H3>GetHilbertSpaceDimension :</H3>
<u>prototype:</u>     int GetHilbertSpaceDimension  ()<BR><BR>
<u>description:</u>return dimension of Hilbert space where Hamiltonian acts 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> corresponding matrix elementdimension 
<BR>
<BR><BR><BR><H3>ShiftHamiltonian :</H3>
<u>prototype:</u>     void ShiftHamiltonian  (double shift )<BR><BR>
<u>description:</u>shift Hamiltonian from a given energy 
<BR><BR><BR>
<u>input parameters:</u>
<BR>shift = shift value 
<BR>
<BR><BR><BR><H3>MatrixElement :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Complex.html">Complex</A> MatrixElement  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& V2 )<BR><BR>
<u>description:</u>evaluate matrix element 
<BR><BR><BR>
<u>input parameters:</u>
<BR>V1 = vector to left multiply with current matrix 
<BR>V2 = vector to right multiply with current matrix 
<BR><BR><BR>
<u>return value:</u> corresponding matrix element 
<BR>
<BR><BR><BR><H3>MatrixElement :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Complex.html">Complex</A> MatrixElement  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& V2 )<BR><BR>
<u>description:</u>evaluate matrix element 
<BR><BR><BR>
<u>input parameters:</u>
<BR>V1 = vector to left multiply with current matrix 
<BR>V2 = vector to right multiply with current matrix 
<BR><BR><BR>
<u>return value:</u> corresponding matrix element 
<BR>
<BR><BR><BR><H3>LowLevelMultiply :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& LowLevelMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& vDestination )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian and store result in another vector 
<BR>low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector where result has to be stored 
<BR><BR><BR>
<u>return value:</u> reference on vectorwhere result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelMultiply :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& LowLevelMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , 
  int , int nbrComponent )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of idinces  
<BR>and store result in another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector where result has to be stored 
<BR>firstComponent = index of the first component to evaluate 
<BR>nbrComponent = number of components to evaluate 
<BR><BR><BR>
<u>return value:</u> reference on vector where result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelAddMultiply :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& LowLevelAddMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& vDestination )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and add result to another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector at which result has to be added 
<BR><BR><BR>
<u>return value:</u> reference on vectorwhere result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelAddMultiply :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& LowLevelAddMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , 
  int , int nbrComponent )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and add result to another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector at which result has to be added 
<BR>firstComponent = index of the first component to evaluate 
<BR>nbrComponent = number of components to evaluate 
<BR><BR><BR>
<u>return value:</u> reference on vector where result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelMultiply :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& LowLevelMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& vDestination )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian and store result in another vector 
<BR>low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector where result has to be stored 
<BR><BR><BR>
<u>return value:</u> reference on vectorwhere result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelMultiply :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& LowLevelMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , 
  int , int nbrComponent )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and store result in another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector where result has to be stored 
<BR>firstComponent = index of the first component to evaluate 
<BR>nbrComponent = number of components to evaluate 
<BR><BR><BR>
<u>return value:</u> reference on vector where result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelAddMultiply :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& LowLevelAddMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& vDestination )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and add result to another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector at which result has to be added 
<BR><BR><BR>
<u>return value:</u> reference on vectorwhere result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelAddMultiply :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& LowLevelAddMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , 
  int , int nbrComponent )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and add result to another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector at which result has to be added 
<BR>firstComponent = index of the first component to evaluate 
<BR>nbrComponent = number of components to evaluate 
<BR><BR><BR>
<u>return value:</u> reference on vector where result has been stored 
<BR>
<BR><BR><BR><H3>LeftInteractionOperators :</H3>
<u>prototype:</u>     List<Matrix*> LeftInteractionOperators  ()<BR><BR>
<u>description:</u>return a list of left interaction operators 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> list of left interaction operators 
<BR>
<BR><BR><BR><H3>RightInteractionOperators :</H3>
<u>prototype:</u>     List<Matrix*> RightInteractionOperators  ()<BR><BR>
<u>description:</u>return a list of right interaction operators  
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> list of right interaction operators 
<BR>
<BR><BR><BR><H3>operator << :</H3>
<u>prototype:</u>     <i>friend</i> ostream& operator <<  (ostream& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Hamiltonian/SpinHamiltonian/PeriodicAnisotropicSpinChainHamiltonian.html">PeriodicAnisotropicSpinChainHamiltonian</A>& H )<BR><BR>
<u>description:</u>Output Stream overload 
<BR><BR><BR>
<u>input parameters:</u>
<BR>Str = reference on output stream 
<BR>H = Hamiltonian to print 
<BR><BR><BR>
<u>return value:</u> reference on output stream 
<BR>
<BR><BR><BR><H3>operator << :</H3>
<u>prototype:</u>     <i>friend</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Output/MathematicaOutput.html">MathematicaOutput</A>& operator <<  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Output/MathematicaOutput.html">MathematicaOutput</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Hamiltonian/SpinHamiltonian/PeriodicAnisotropicSpinChainHamiltonian.html">PeriodicAnisotropicSpinChainHamiltonian</A>& H )<BR><BR>
<u>description:</u>Mathematica Output Stream overload 
<BR><BR><BR>
<u>input parameters:</u>
<BR>Str = reference on Mathematica output stream 
<BR>H = Hamiltonian to print 
<BR><BR><BR>
<u>return value:</u> reference on output stream 
<BR>
<BR><BR><BR>	Back to <A HREF="/home/regnault/development/Physics/DiagHam/docs/index.html">index</A>. 

  </body>
</html>
