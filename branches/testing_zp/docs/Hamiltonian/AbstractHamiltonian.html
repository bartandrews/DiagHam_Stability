<html>
  <head>
    <title>AbstractHamiltonian</title>
  </head>

  <body>
    <H1><DIV align=center>Class : AbstractHamiltonian</DIV></H1>

<H3>~AbstractHamiltonian :</H3>
<u>prototype:</u>     <i>virtual</i> ~AbstractHamiltonian  ()<BR><BR>
<u>description:</u>destructor 
<BR>
<BR><BR><BR><H3>SetHilbertSpace :</H3>
<u>prototype:</u>     <i>virtual</i> void SetHilbertSpace  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/AbstractHilbertSpace.html">AbstractHilbertSpace</A>* hilbertSpace )<BR><BR>
<u>description:</u>clone hamiltonian without duplicating datas 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> pointer to cloned hamiltonian 
<BR>virtual AbstractHamiltonian* Clone () = 0; 
<BR>set Hilbert space 
<BR><BR><BR>
<u>input parameters:</u>
<BR>hilbertSpace = pointer to Hilbert space to use 
<BR>
<BR><BR><BR><H3>GetHilbertSpace :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/AbstractHilbertSpace.html">AbstractHilbertSpace</A>* GetHilbertSpace  ()<BR><BR>
<u>description:</u>get Hilbert space on which Hamiltonian acts 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> pointer to used Hilbert space 
<BR>
<BR><BR><BR><H3>GetHilbertSpaceDimension :</H3>
<u>prototype:</u>     <i>virtual</i> int GetHilbertSpaceDimension  ()<BR><BR>
<u>description:</u>return dimension of Hilbert space where Hamiltonian acts 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> corresponding matrix elementdimension 
<BR>
<BR><BR><BR><H3>ShiftHamiltonian :</H3>
<u>prototype:</u>     <i>virtual</i> void ShiftHamiltonian  (double shift )<BR><BR>
<u>description:</u>shift Hamiltonian from a given energy 
<BR><BR><BR>
<u>input parameters:</u>
<BR>shift = shift value 
<BR>
<BR><BR><BR><H3>GetHamiltonian :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/HermitianMatrix.html">HermitianMatrix</A>& GetHamiltonian  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/HermitianMatrix.html">HermitianMatrix</A>& M )<BR><BR>
<u>description:</u>store Hamiltonian into an hermitian matrix 
<BR><BR><BR>
<u>input parameters:</u>
<BR>M = reference on matrix where Hamiltonian has to be stored 
<BR><BR><BR>
<u>return value:</u> reference on  corresponding hermitian matrix 
<BR>
<BR><BR><BR><H3>GetHamiltonian :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/RealSymmetricMatrix.html">RealSymmetricMatrix</A>& GetHamiltonian  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/RealSymmetricMatrix.html">RealSymmetricMatrix</A>& M )<BR><BR>
<u>description:</u>store real part of Hamiltonian into a real symmetric matrix 
<BR><BR><BR>
<u>input parameters:</u>
<BR>M = reference on matrix where Hamiltonian has to be stored 
<BR><BR><BR>
<u>return value:</u> reference on  corresponding real symmetric matrix  
<BR>
<BR><BR><BR><H3>GetHamiltonian :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/Matrix.html">Matrix</A>& GetHamiltonian  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/Matrix.html">Matrix</A>& M )<BR><BR>
<u>description:</u>store real part of Hamiltonian into a matrix 
<BR><BR><BR>
<u>input parameters:</u>
<BR>M = reference on matrix where Hamiltonian has to be stored 
<BR><BR><BR>
<u>return value:</u> reference on  corresponding matrix  
<BR>
<BR><BR><BR><H3>GetHamiltonian :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/Matrix.html">Matrix</A>* GetHamiltonian  ()<BR><BR>
<u>description:</u>return matrix representation of current Hamiltonian 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> reference to representation 
<BR>
<BR><BR><BR><H3>GetHamiltonianPicture :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/BitmapPicture/AbstractBitmapPicture.html">AbstractBitmapPicture</A>* GetHamiltonianPicture  (double error )<BR><BR>
<u>description:</u>store Hamiltonian into a picture (drawing non zero element in black) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>error = absolute minimum value to be considered as non zero element 
<BR><BR><BR>
<u>return value:</u> pointer to the picture associated to the matrix 
<BR>
<BR><BR><BR><H3>GetHamiltonianColorPicture :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/BitmapPicture/AbstractBitmapPicture.html">AbstractBitmapPicture</A>* GetHamiltonianColorPicture  (double error )<BR><BR>
<u>description:</u>store Hamiltonian into a picture (drawing non zero element with a color scale) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>error = absolute minimum value to be considered as non zero element 
<BR><BR><BR>
<u>return value:</u> pointer to the picture associated to the matrix 
<BR>
<BR><BR><BR><H3>LeftInteractionOperators :</H3>
<u>prototype:</u>     <i>virtual</i> List<Matrix*> LeftInteractionOperators  ()<BR><BR>
<u>description:</u>return a list of left interaction operators 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> list of left interaction operators 
<BR>
<BR><BR><BR><H3>RightInteractionOperators :</H3>
<u>prototype:</u>     <i>virtual</i> List<Matrix*> RightInteractionOperators  ()<BR><BR>
<u>description:</u>return a list of right interaction operators 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> list of right interaction operators 
<BR>
<BR><BR><BR><H3>MatrixElement :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Complex.html">Complex</A> MatrixElement  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& V2 )<BR><BR>
<u>description:</u>evaluate matrix element 
<BR><BR><BR>
<u>input parameters:</u>
<BR>V1 = vector to left multiply with current matrix 
<BR>V2 = vector to right multiply with current matrix 
<BR><BR><BR>
<u>return value:</u> corresponding matrix element 
<BR>
<BR><BR><BR><H3>MatrixElement :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Complex.html">Complex</A> MatrixElement  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& V2 )<BR><BR>
<u>description:</u>evaluate matrix element 
<BR><BR><BR>
<u>input parameters:</u>
<BR>V1 = vector to left multiply with current matrix 
<BR>V2 = vector to right multiply with current matrix 
<BR><BR><BR>
<u>return value:</u> corresponding matrix element 
<BR>
<BR><BR><BR><H3>LowLevelMultiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& LowLevelMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& vDestination )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian and store result in another vector 
<BR>low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector where result has to be stored 
<BR><BR><BR>
<u>return value:</u> reference on vectorwhere result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelMultiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& LowLevelMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , 
  int , int nbrComponent )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and store result in another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector where result has to be stored 
<BR>firstComponent = index of the first component to evaluate 
<BR>nbrComponent = number of components to evaluate 
<BR><BR><BR>
<u>return value:</u> reference on vector where result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelAddMultiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& LowLevelAddMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& vDestination )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and add result to another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector at which result has to be added 
<BR><BR><BR>
<u>return value:</u> reference on vectorwhere result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelAddMultiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& LowLevelAddMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , 
  int , int nbrComponent )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and add result to another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector at which result has to be added 
<BR>firstComponent = index of the first component to evaluate 
<BR>nbrComponent = number of components to evaluate 
<BR><BR><BR>
<u>return value:</u> reference on vector where result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelMultiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& LowLevelMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& vDestination )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian and store result in another vector 
<BR>low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector where result has to be stored 
<BR><BR><BR>
<u>return value:</u> reference on vectorwhere result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelMultiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& LowLevelMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , 
  int , int nbrComponent )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and store result in another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector where result has to be stored 
<BR>firstComponent = index of the first component to evaluate 
<BR>nbrComponent = number of components to evaluate 
<BR><BR><BR>
<u>return value:</u> reference on vector where result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelAddMultiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& LowLevelAddMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& vDestination )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and add result to another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector at which result has to be added 
<BR><BR><BR>
<u>return value:</u> reference on vectorwhere result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelAddMultiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& LowLevelAddMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , 
  int , int nbrComponent )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and add result to another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector at which result has to be added 
<BR>firstComponent = index of the first component to evaluate 
<BR>nbrComponent = number of components to evaluate 
<BR><BR><BR>
<u>return value:</u> reference on vector where result has been stored 
<BR>
<BR><BR><BR><H3>Multiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/Vector.html">Vector</A>& Multiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/Vector.html">Vector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/Vector.html">Vector</A>& vDestination )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian and store result in another vector 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector where result has to be stored 
<BR><BR><BR>
<u>return value:</u> reference on vectorwhere result has been stored 
<BR>
<BR><BR><BR><H3>Multiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/Vector.html">Vector</A>& Multiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/Vector.html">Vector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/Vector.html">Vector</A>& , 
  int , int nbrComponent )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and store result in another vector 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector where result has to be stored 
<BR>firstComponent = index of the first component to evaluate 
<BR>nbrComponent = number of components to evaluate 
<BR><BR><BR>
<u>return value:</u> reference on vector where result has been stored 
<BR>
<BR><BR><BR><H3>AddMultiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/Vector.html">Vector</A>& AddMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/Vector.html">Vector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/Vector.html">Vector</A>& vDestination )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and add result to another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector at which result has to be added 
<BR><BR><BR>
<u>return value:</u> reference on vectorwhere result has been stored 
<BR>
<BR><BR><BR><H3>AddMultiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/Vector.html">Vector</A>& AddMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/Vector.html">Vector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/Vector.html">Vector</A>& , 
  int , int nbrComponent )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian for a given range of indices  
<BR>and add result to another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector at which result has to be added 
<BR>firstComponent = index of the first component to evaluate 
<BR>nbrComponent = number of components to evaluate 
<BR><BR><BR>
<u>return value:</u> reference on vector where result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelMultiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& LowLevelMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , int nbrProcess )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian using threads 
<BR>and store result in another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector where result has to be stored 
<BR>nbrProcess = number of process to run 
<BR><BR><BR>
<u>return value:</u> reference on vector where result has been stored 
<BR>
<BR><BR><BR><H3>LowLevelMultiply :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& LowLevelMultiply  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& , int nbrProcess )<BR><BR>
<u>description:</u>multiply a vector by the current hamiltonian using threads 
<BR>and store result in another vector, low level function (no architecture optimization) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>vSource = vector to be multiplied 
<BR>vDestination = vector where result has to be stored 
<BR>nbrProcess = number of process to run 
<BR><BR><BR>
<u>return value:</u> reference on vector where result has been stored 
<BR>
<BR><BR><BR><H3>Lanczos :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/RealTriDiagonalSymmetricMatrix.html">RealTriDiagonalSymmetricMatrix</A>& Lanczos  (int , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/RealTriDiagonalSymmetricMatrix.html">RealTriDiagonalSymmetricMatrix</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/ComplexVector.html">ComplexVector</A>& V1 )<BR><BR>
<u>description:</u>Tridiagonalize an hermitian matrix using Lanczos algorithm without re-orthogonalizing base at each step 
<BR><BR><BR>
<u>input parameters:</u>
<BR>dimension = maximum iteration number 
<BR>M = reference on complex tridiagonal hermitian matrix where result has to be stored 
<BR>V1 = reference on complex vector used as first vector (will contain last produced vector at the end) 
<BR><BR><BR>
<u>return value:</u> reference on complex tridiagonal hermitian matrix 
<BR>
<BR><BR><BR><H3>ReorthogonalizedLanczos :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/RealTriDiagonalSymmetricMatrix.html">RealTriDiagonalSymmetricMatrix</A>& ReorthogonalizedLanczos  (int , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/RealTriDiagonalSymmetricMatrix.html">RealTriDiagonalSymmetricMatrix</A>& , 
  <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , int step = 1 )<BR><BR>
<u>description:</u>Tridiagonalize hamiltonian using Lanczos algorithm with partial base re-orthogonalization 
<BR><BR><BR>
<u>input parameters:</u>
<BR>dimension = maximum iteration number 
<BR>M = reference on complex tridiagonal hermitian matrix where result has to be stored 
<BR>V1 = reference on real vector used as first vector (will contain last produced vector at the end) 
<BR>step = number of iterations before re-orthogonalizing whole base 
<BR><BR><BR>
<u>return value:</u> reference on complex tridiagonal hermitian matrix 
<BR>
<BR><BR><BR><H3>FullReorthogonalizedLanczos :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/RealTriDiagonalSymmetricMatrix.html">RealTriDiagonalSymmetricMatrix</A>& FullReorthogonalizedLanczos  (int , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/RealTriDiagonalSymmetricMatrix.html">RealTriDiagonalSymmetricMatrix</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& V1 )<BR><BR>
<u>description:</u>Tridiagonalize hamiltonian using Lanczos algorithm with base re-orthogonalization 
<BR><BR><BR>
<u>input parameters:</u>
<BR>dimension = maximum iteration number 
<BR>M = reference on real tridiagonal hermitian matrix where result has to be stored 
<BR>V1 = reference on real vector used as first vector (will contain last produced vector at the end) 
<BR><BR><BR>
<u>return value:</u> reference on complex tridiagonal hermitian matrix 
<BR>
<BR><BR><BR><H3>Lanczos :</H3>
<u>prototype:</u>     <i>virtual</i> <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/RealTriDiagonalSymmetricMatrix.html">RealTriDiagonalSymmetricMatrix</A>& Lanczos  (int , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/RealTriDiagonalSymmetricMatrix.html">RealTriDiagonalSymmetricMatrix</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& V1 )<BR><BR>
<u>description:</u>Tridiagonalize an hermitian matrix using Lanczos algorithm without re-orthogonalizing base at each step 
<BR><BR><BR>
<u>input parameters:</u>
<BR>dimension = maximum iteration number 
<BR>M = reference on complex tridiagonal hermitian matrix where result has to be stored 
<BR>V1 = reference on complex vector used as first vector (will contain last produced vector at the end) 
<BR><BR><BR>
<u>return value:</u> reference on complex tridiagonal hermitian matrix 
<BR>
<BR><BR><BR><H3>Lanczos :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/RealTriDiagonalSymmetricMatrix.html">RealTriDiagonalSymmetricMatrix</A>& Lanczos  (int , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Matrix/RealTriDiagonalSymmetricMatrix.html">RealTriDiagonalSymmetricMatrix</A>& , 
  <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , <A HREF="/home/regnault/development/Physics/DiagHam/docs/Vector/RealVector.html">RealVector</A>& , bool useV2 = false )<BR><BR>
<u>description:</u>Tridiagonalize an hermitian matrix using Lanczos algorithm without re-orthogonalizing base at each step 
<BR><BR><BR>
<u>input parameters:</u>
<BR>dimension = maximum iteration number 
<BR>M = reference on real tridiagonal symmetric matrix where result has to be stored 
<BR>V1 = reference on real vector used as first vector (will contain last produced vector at the end) 
<BR>V2 = reference on real vector used as second vector (will contain next to last produced vector at the end) 
<BR>useV2 = true if V2 already contains result of second Lanczos iteration, in that case M is supposed to give 
<BR>results of previous Lanczos iteration 
<BR><BR><BR>
<u>return value:</u> reference on real tridiagonal symmetric matrix 
<BR>
<BR><BR><BR>	Back to <A HREF="/home/regnault/development/Physics/DiagHam/docs/index.html">index</A>. 

  </body>
</html>
