<html>
  <head>
    <title>AbstractSpinChainWithTranslations</title>
  </head>

  <body>
    <H1><DIV align=center>Class : AbstractSpinChainWithTranslations</DIV></H1>

<DIV ALIGN="CENTER">class deriving from <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/AbstractHilbertSpace.html">AbstractHilbertSpace</A></DIV><BR>
<H3>~AbstractSpinChainWithTranslations :</H3>
<u>prototype:</u>     <i>virtual</i> ~AbstractSpinChainWithTranslations  ()<BR><BR>
<u>description:</u>virtual destructor 
<BR>
<BR><BR><BR><H3>TotalSz :</H3>
<u>prototype:</u>     <i>virtual</i> int TotalSz  (int state )<BR><BR>
<u>description:</u><BR><BR>
<u>return value:</u> return value of spin projection on (Oz) for a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>Str = reference on current output stream  
<BR><BR><BR>
<u>return value:</u> spin projection on (Oz) 
<BR>
<BR><BR><BR><H3>TotalSzSz :</H3>
<u>prototype:</u>     <i>virtual</i> double TotalSzSz  (int index )<BR><BR>
<u>description:</u><BR><BR>
<u>return value:</u> return value of the value of the sum of the square of spin projection on (Oz)  
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state to test 
<BR><BR><BR>
<u>return value:</u> twice spin projection on (Oz) 
<BR>
<BR><BR><BR><H3>GetMomentum :</H3>
<u>prototype:</u>     <i>virtual</i> int GetMomentum  ()<BR><BR>
<u>description:</u>get the momentum of each state in the current Hilbert space 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> momentum value 
<BR>
<BR><BR><BR><H3>SziSzj :</H3>
<u>prototype:</u>     <i>virtual</i> double SziSzj  (int , int , int state )<BR><BR>
<u>description:</u>return eigenvalue of Sz_i Sz_j associated to a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = first position 
<BR>j = second position 
<BR>state = index of the state to consider 
<BR><BR><BR>
<u>return value:</u> corresponding eigenvalue 
<BR>
<BR><BR><BR><H3>SpiSpj :</H3>
<u>prototype:</u>     <i>virtual</i> int SpiSpj  (int , int , int , double& , int& nbrTranslation )<BR><BR>
<u>description:</u>return index of resulting state from application of S+_i S+_j operator on a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = position of first S+ operator 
<BR>j = position of second S+ operator 
<BR>state = index of the state to be applied on S+_i S+_j operator 
<BR>coefficient = reference on double where numerical coefficient has to be stored 
<BR>nbrTranslations = reference on the number of translations to applied to the resulting state to obtain the return orbit describing state 
<BR><BR><BR>
<u>return value:</u> index of resulting state 
<BR>
<BR><BR><BR><H3>SmiSmj :</H3>
<u>prototype:</u>     <i>virtual</i> int SmiSmj  (int , int , int , double& , int& nbrTranslation )<BR><BR>
<u>description:</u>return index of resulting state from application of S-_i S-_j operator on a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = position of first S- operator 
<BR>j = position of second S- operator 
<BR>state = index of the state to be applied on S-_i S-_j operator 
<BR>coefficient = reference on double where numerical coefficient has to be stored 
<BR>nbrTranslations = reference on the number of translations to applied to the resulting state to obtain the return orbit describing state 
<BR><BR><BR>
<u>return value:</u> index of resulting state 
<BR>
<BR><BR><BR><H3>SpiSpi :</H3>
<u>prototype:</u>     <i>virtual</i> int SpiSpi  (int , int , double& , int& nbrTranslation )<BR><BR>
<u>description:</u>return index of resulting state from application of S+_i S+_i operator on a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = position of first S+ operator 
<BR>state = index of the state to be applied on S+_i S+_i operator 
<BR>coefficient = reference on double where numerical coefficient has to be stored 
<BR>nbrTranslations = reference on the number of translations to applied to the resulting state to obtain the return orbit describing state 
<BR><BR><BR>
<u>return value:</u> index of resulting state 
<BR>
<BR><BR><BR><H3>SmiSmi :</H3>
<u>prototype:</u>     <i>virtual</i> int SmiSmi  (int , int , double& , int& nbrTranslation )<BR><BR>
<u>description:</u>return index of resulting state from application of S-_i S-_i operator on a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = position of the S- operator 
<BR>state = index of the state to be applied on S-_i S-_i operator 
<BR>coefficient = reference on double where numerical coefficient has to be stored 
<BR>nbrTranslations = reference on the number of translations to applied to the resulting state to obtain the return orbit describing state 
<BR><BR><BR>
<u>return value:</u> index of resulting state 
<BR>
<BR><BR><BR><H3>SpiSzj :</H3>
<u>prototype:</u>     <i>virtual</i> int SpiSzj  (int , int , int , double& , int& nbrTranslation )<BR><BR>
<u>description:</u>return index of resulting state from application of S+_i Sz_j operator on a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = position of S+ operator 
<BR>j = position of Sz operator 
<BR>state = index of the state to be applied on S+_i Sz_j operator 
<BR>coefficient = reference on double where numerical coefficient has to be stored 
<BR>nbrTranslations = reference on the number of translations to applied to the resulting state to obtain the return orbit describing state 
<BR><BR><BR>
<u>return value:</u> index of resulting state 
<BR>
<BR><BR><BR><H3>SmiSzj :</H3>
<u>prototype:</u>     <i>virtual</i> int SmiSzj  (int , int , int , double& , int& nbrTranslation )<BR><BR>
<u>description:</u>return index of resulting state from application of S-_i Sz_j operator on a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = position of S- operator 
<BR>j = position of Sz operator 
<BR>state = index of the state to be applied on S-_i Sz_j operator 
<BR>coefficient = reference on double where numerical coefficient has to be stored 
<BR>nbrTranslations = reference on the number of translations to applied to the resulting state to obtain the return orbit describing state 
<BR><BR><BR>
<u>return value:</u> index of resulting state 
<BR>
<BR><BR><BR><H3>SmiSpj :</H3>
<u>prototype:</u>     <i>virtual</i> int SmiSpj  (int , int , int , double& , int& nbrTranslation )<BR><BR>
<u>description:</u>return index of resulting state from application of S-_i S+_j operator on a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = position of S- operator 
<BR>j = position of S+ operator 
<BR>state = index of the state to be applied on S-_i S+_j operator 
<BR>coefficient = reference on double where numerical coefficient has to be stored 
<BR>nbrTranslations = reference on the number of translations to applied to the resulting state to obtain the return orbit describing state 
<BR><BR><BR>
<u>return value:</u> index of resulting state (orbit index) 
<BR>
<BR><BR><BR><H3>Spi :</H3>
<u>prototype:</u>     <i>virtual</i> int Spi  (int , int , double& , int& nbrTranslation )<BR><BR>
<u>description:</u>return index of resulting state from application of S+_i operator on a given state (only valid if there is no constraint on total Sz) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = operator position 
<BR>state = index of the state to be applied on S+_i S+_j operator 
<BR>coefficient = reference on double where numerical coefficient has to be stored 
<BR>nbrTranslations = reference on the number of translations to applied to the resulting state to obtain the return orbit describing state 
<BR><BR><BR>
<u>return value:</u> index of resulting state 
<BR>
<BR><BR><BR><H3>Smi :</H3>
<u>prototype:</u>     <i>virtual</i> int Smi  (int , int , double& , int& nbrTranslation )<BR><BR>
<u>description:</u>return index of resulting state from application of S-_i operator on a given state (only valid if there is no constraint on total Sz) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = operator position 
<BR>state = index of the state to be applied on S+_i S+_j operator 
<BR>coefficient = reference on double where numerical coefficient has to be stored 
<BR>nbrTranslations = reference on the number of translations to applied to the resulting state to obtain the return orbit describing state 
<BR><BR><BR>
<u>return value:</u> index of resulting state 
<BR>
<BR><BR><BR><H3>FindStateIndex :</H3>
<u>prototype:</u>     <i>virtual</i> int FindStateIndex  (unsigned long state )<BR><BR>
<u>description:</u>find state index 
<BR><BR><BR>
<u>input parameters:</u>
<BR>state = state description 
<BR><BR><BR>
<u>return value:</u> corresponding index 
<BR>
<BR><BR><BR>	Back to <A HREF="/home/regnault/development/Physics/DiagHam/docs/index.html">index</A>. 

  </body>
</html>
