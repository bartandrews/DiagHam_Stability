<html>
  <head>
    <title>FermionOnTorusWithSpin</title>
  </head>

  <body>
    <H1><DIV align=center>Class : FermionOnTorusWithSpin</DIV></H1>

<DIV ALIGN="CENTER">class deriving from <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/QHEHilbertSpace/ParticleOnTorusWithSpin.html">ParticleOnTorusWithSpin</A></DIV><BR>
<H3>FermionOnTorusWithSpin :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/QHEHilbertSpace/FermionOnTorusWithSpin.html">FermionOnTorusWithSpin</A>  (int , int maxMomentum )<BR><BR>
<u>description:</u>basic constructor 
<BR><BR><BR>
<u>input parameters:</u>
<BR>nbrFermions = number of fermions 
<BR>maxMomentum = momentum maximum value for a fermion 
<BR>
<BR><BR><BR><H3>FermionOnTorusWithSpin :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/QHEHilbertSpace/FermionOnTorusWithSpin.html">FermionOnTorusWithSpin</A>  (int , int , int totalSpinMomentum )<BR><BR>
<u>description:</u>constructor with a constraint on total spin momentum 
<BR><BR><BR>
<u>input parameters:</u>
<BR>nbrFermions = number of fermions 
<BR>maxMomentum = momentum maximum value for a fermion 
<BR>totalSpinMomentum = twice the total spin momentum to be used as constraint 
<BR>
<BR><BR><BR><H3>FermionOnTorusWithSpin :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/QHEHilbertSpace/FermionOnTorusWithSpin.html">FermionOnTorusWithSpin</A>  (int , int , int , int momentumConstaint )<BR><BR>
<u>description:</u>constructor with a constraint on total spin momentum and total momentum 
<BR><BR><BR>
<u>input parameters:</u>
<BR>nbrFermions = number of fermions 
<BR>maxMomentum = momentum maximum value for a fermion 
<BR>totalSpinMomentum = twice the total spin momentum to be used as constraint 
<BR>momentumConstraint = index of the momentum orbit 
<BR>
<BR><BR><BR><H3>FermionOnTorusWithSpin :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/QHEHilbertSpace/FermionOnTorusWithSpin.html">FermionOnTorusWithSpin</A>  (int , int , int , int , unsigned int* , 
  int* , bool momentumConstraintFlag = , int momentumConstraint = 0 )<BR><BR>
<u>description:</u>constructor from full datas 
<BR><BR><BR>
<u>input parameters:</u>
<BR>nbrFermions = number of fermions 
<BR>maxMomentum = momentum maximum value for a fermion 
<BR>totalSpinMomentum = twice the total spin momentum to be used as constraint 
<BR>hilbertSpaceDimension = Hilbert space dimension 
<BR>stateDescription = array describing each state 
<BR>stateMaxMomentum = array giving maximum Lz value reached for a fermion in a given state 
<BR>momentumConstraintFlag = flag for momementum constraint 
<BR>momentumConstraint = index of the momentum orbit 
<BR>
<BR><BR><BR><H3>FermionOnTorusWithSpin :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/QHEHilbertSpace/FermionOnTorusWithSpin.html">FermionOnTorusWithSpin</A>  (const <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/QHEHilbertSpace/FermionOnTorusWithSpin.html">FermionOnTorusWithSpin</A>& fermions )<BR><BR>
<u>description:</u>copy constructor (without duplicating datas) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>fermions = reference on the hilbert space to copy to copy 
<BR>
<BR><BR><BR><H3>~FermionOnTorusWithSpin :</H3>
<u>prototype:</u>     ~FermionOnTorusWithSpin  ()<BR><BR>
<u>description:</u>destructor 
<BR>
<BR><BR><BR><H3>operator = :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/QHEHilbertSpace/FermionOnTorusWithSpin.html">FermionOnTorusWithSpin</A>& operator =  (const <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/QHEHilbertSpace/FermionOnTorusWithSpin.html">FermionOnTorusWithSpin</A>& fermions )<BR><BR>
<u>description:</u>assignement (without duplicating datas) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>fermions = reference on the hilbert space to copy to copy 
<BR><BR><BR>
<u>return value:</u> reference on current hilbert space 
<BR>
<BR><BR><BR><H3>Clone :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/AbstractHilbertSpace.html">AbstractHilbertSpace</A>* Clone  ()<BR><BR>
<u>description:</u>clone Hilbert space (without duplicating datas) 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> pointer to cloned Hilbert space 
<BR>
<BR><BR><BR><H3>GetParticleStatistic :</H3>
<u>prototype:</u>     int GetParticleStatistic  ()<BR><BR>
<u>description:</u>get the particle statistic  
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> particle statistic 
<BR>
<BR><BR><BR><H3>GetQuantumNumbers :</H3>
<u>prototype:</u>     List<AbstractQuantumNumber*> GetQuantumNumbers  ()<BR><BR>
<u>description:</u>return a list of all possible quantum numbers  
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> pointer to corresponding quantum number 
<BR>
<BR><BR><BR><H3>GetQuantumNumber :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/QuantumNumber/AbstractQuantumNumber.html">AbstractQuantumNumber</A>* GetQuantumNumber  (int index )<BR><BR>
<u>description:</u>return quantum number associated to a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state 
<BR><BR><BR>
<u>return value:</u> pointer to corresponding quantum number 
<BR>
<BR><BR><BR><H3>GetMomentumValue :</H3>
<u>prototype:</u>     int GetMomentumValue  (int index )<BR><BR>
<u>description:</u>get momemtum value of a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = state index 
<BR><BR><BR>
<u>return value:</u> state momentum 
<BR>
<BR><BR><BR><H3>ExtractSubspace :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/AbstractHilbertSpace.html">AbstractHilbertSpace</A>* ExtractSubspace  (<A HREF="/home/regnault/development/Physics/DiagHam/docs/QuantumNumber/AbstractQuantumNumber.html">AbstractQuantumNumber</A>& , 
  <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/SubspaceSpaceConverter.html">SubspaceSpaceConverter</A>& converter )<BR><BR>
<u>description:</u>extract subspace with a fixed quantum number 
<BR><BR><BR>
<u>input parameters:</u>
<BR>q = quantum number value 
<BR>converter = reference on subspace-space converter to use 
<BR><BR><BR>
<u>return value:</u> pointer to the new subspace 
<BR>
<BR><BR><BR><H3>SumAudAu :</H3>
<u>prototype:</u>     int SumAudAu  (int , double& coefficient )<BR><BR>
<u>description:</u>apply sum_m au^+_m au_m operator to a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>SumAddAd :</H3>
<u>prototype:</u>     int SumAddAd  (int , double& coefficient )<BR><BR>
<u>description:</u>apply sum_m ad^+_m ad_m operator to a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AudAu :</H3>
<u>prototype:</u>     int AudAu  (int , int , double& coefficient )<BR><BR>
<u>description:</u>apply au^+_m au_m operator to a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m = index for density operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AddAd :</H3>
<u>prototype:</u>     int AddAd  (int , int , double& coefficient )<BR><BR>
<u>description:</u>apply ad^+_m ad_m operator to a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m = index for density operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AudAudAuAu :</H3>
<u>prototype:</u>     int AudAudAuAu  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply au^+_m1 au^+_m2 au_n1 au_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AddAddAdAd :</H3>
<u>prototype:</u>     int AddAddAdAd  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply ad^+_m1 ad^+_m2 ad_n1 ad_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AddAddAuAu :</H3>
<u>prototype:</u>     int AddAddAuAu  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply ad^+_m1 ad^+_m2 au_n1 au_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AudAudAdAd :</H3>
<u>prototype:</u>     int AudAudAdAd  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply au^+_m1 au^+_m2 ad_n1 ad_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AudAudAuAd :</H3>
<u>prototype:</u>     int AudAudAuAd  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply au^+_m1 au^+_m2 au_n1 ad_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AddAudAuAu :</H3>
<u>prototype:</u>     int AddAudAuAu  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply ad^+_m1 au^+_m2 au_n1 au_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AddAddAdAu :</H3>
<u>prototype:</u>     int AddAddAdAu  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply ad^+_m1 ad^+_m2 ad_n1 au_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AudAddAdAd :</H3>
<u>prototype:</u>     int AudAddAdAd  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply au^+_m1 ad^+_m2 ad_n1 ad_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AudAddAuAd :</H3>
<u>prototype:</u>     int AudAddAuAd  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply au^+_m1 ad^+_m2 au_n1 ad_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>PrintState :</H3>
<u>prototype:</u>     ostream& PrintState  (ostream& , int state )<BR><BR>
<u>description:</u>print a given State 
<BR><BR><BR>
<u>input parameters:</u>
<BR>Str = reference on current output stream  
<BR>state = ID of the state to print 
<BR><BR><BR>
<u>return value:</u> reference on current output stream  
<BR>
<BR><BR><BR>	Back to <A HREF="/home/regnault/development/Physics/DiagHam/docs/index.html">index</A>. 

  </body>
</html>
