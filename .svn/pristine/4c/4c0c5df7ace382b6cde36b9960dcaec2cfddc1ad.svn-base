<html>
  <head>
    <title>Spin1_2Chain</title>
  </head>

  <body>
    <H1><DIV align=center>Class : Spin1_2Chain</DIV></H1>

<H3>Spin1_2Chain :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/DMRG/AKLT/docs/HilbertSpace/Spin1_2Chain.html">Spin1_2Chain</A>  ()<BR><BR>
<u>description:</u>default constructor 
<BR>
<BR><BR><BR><H3>Spin1_2Chain :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/DMRG/AKLT/docs/HilbertSpace/Spin1_2Chain.html">Spin1_2Chain</A>  (int chainLength int memorySize )<BR><BR>
<u>description:</u>constructor for complete Hilbert space with no restriction on total spin projection Sz 
<BR><BR><BR>
<u>input parameters:</u>
<BR>chainLength = number of spin 1/2 
<BR>memorySize = memory size in bytes allowed for look-up table 
<BR>
<BR><BR><BR><H3>Spin1_2Chain :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/DMRG/AKLT/docs/HilbertSpace/Spin1_2Chain.html">Spin1_2Chain</A>  (int chainLength int sz int memorySize )<BR><BR>
<u>description:</u>constructor for complete Hilbert space with no restriction on total spin projection Sz 
<BR><BR><BR>
<u>input parameters:</u>
<BR>chainLength = number of spin 1/2 
<BR>sz = twice the value of total Sz component 
<BR>memorySize = memory size in bytes allowed for look-up table 
<BR>
<BR><BR><BR><H3>Spin1_2Chain :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/DMRG/AKLT/docs/HilbertSpace/Spin1_2Chain.html">Spin1_2Chain</A>  (int hilbertSpaceDimension unsigned long* chainDescription int chainLength 
  int sz bool fixedQuantumNumberFlag int* lookUpTable int lookUpTableSize 
  int lookUpPosition unsigned long lookUpTableMask )<BR><BR>
<u>description:</u>constructor from pre-constructed datas 
<BR><BR><BR>
<u>input parameters:</u>
<BR>hilbertSpaceDimension = Hilbert space dimension 
<BR>chainDescription = array describing states 
<BR>chainLength = number of spin 1/2 
<BR>sz = twice the value of total Sz component 
<BR>fixedQuantumNumberFlag = true if hilbert space is restricted to a given quantum number 
<BR>lookUpTable = look-up table 
<BR>lookUpTableSize = look-Up table size 
<BR>lookUpTablePosition = last position described by the look-Up table 
<BR>lookUpTableMask = look-Up table mask 
<BR>
<BR><BR><BR><H3>constructor :</H3>
<u>prototype:</u>    copy constructor  (without duplicating datas )<BR><BR>
<u>description:</u>copy constructor (without duplicating datas) 
<BR>
<BR><BR><BR><H3>Spin1_2Chain :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/DMRG/AKLT/docs/HilbertSpace/Spin1_2Chain.html">Spin1_2Chain</A>  (const <A HREF="/home/regnault/development/DMRG/AKLT/docs/HilbertSpace/Spin1_2Chain.html">Spin1_2Chain</A>& chain )<BR><BR>
<u>description:</u><BR><BR>
<u>input parameters:</u>
<BR>chain = reference on chain to copy 
<BR>
<BR><BR><BR><H3>~Spin1_2Chain :</H3>
<u>prototype:</u>     ~Spin1_2Chain  ()<BR><BR>
<u>description:</u>destructor 
<BR>
<BR><BR><BR><H3>assignement :</H3>
<u>prototype:</u>    assignement  (without duplicating datas )<BR><BR>
<u>description:</u>assignement (without duplicating datas) 
<BR>
<BR><BR><BR><H3>operator = :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/DMRG/AKLT/docs/HilbertSpace/Spin1_2Chain.html">Spin1_2Chain</A>& operator =  (const <A HREF="/home/regnault/development/DMRG/AKLT/docs/HilbertSpace/Spin1_2Chain.html">Spin1_2Chain</A>& chain )<BR><BR>
<u>description:</u><BR><BR>
<u>input parameters:</u>
<BR>chain = reference on chain to copy 
<BR><BR><BR>
<u>return value:</u> reference on current chain 
<BR>
<BR><BR><BR><H3>Reinitialize :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/DMRG/AKLT/docs/HilbertSpace/Spin1_2Chain.html">Spin1_2Chain</A>& Reinitialize  (int sz )<BR><BR>
<u>description:</u>re-initialize chain with another total Sz component 
<BR><BR><BR>
<u>input parameters:</u>
<BR>sz = twice the value of total Sz component 
<BR><BR><BR>
<u>return value:</u> reference on current chain   
<BR>
<BR><BR><BR><H3>GetHilbertSpaceDimension :</H3>
<u>prototype:</u>     int GetHilbertSpaceDimension  ()<BR><BR>
<u>description:</u>return Hilbert space dimension 
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> Hilbert space dimension 
<BR>
<BR><BR><BR><H3>GetQuantumNumbers :</H3>
<u>prototype:</u>     List<AbstractQuantumNumber*> GetQuantumNumbers  ()<BR><BR>
<u>description:</u>return a list of all possible quantum numbers  
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> pointer to corresponding quantum number 
<BR>
<BR><BR><BR><H3>GetQuantumNumber :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/DMRG/AKLT/docs/QuantumNumber/AbstractQuantumNumber.html">AbstractQuantumNumber</A>* GetQuantumNumber  (int index )<BR><BR>
<u>description:</u>return quantum number associated to a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state 
<BR><BR><BR>
<u>return value:</u> pointer to corresponding quantum number 
<BR>
<BR><BR><BR><H3>on :</H3>
<u>prototype:</u>    return value of spin projection on  (Oz )<BR><BR>
<u>description:</u><BR><BR>
<u>return value:</u> return value of spin projection on (Oz) for a given state 
<BR>
<BR><BR><BR><H3>on :</H3>
<u>prototype:</u>    return value = spin projection on  (Oz )<BR><BR>
<u>description:</u><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state to test 
<BR><BR><BR>
<u>return value:</u> spin projection on (Oz) 
<BR>
<BR><BR><BR><H3>TotalSz :</H3>
<u>prototype:</u>     int TotalSz  (int index )<BR><BR>
<u>description:</u><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state to test 
<BR><BR><BR>
<u>return value:</u> spin projection on (Oz) 
<BR>
<BR><BR><BR><H3>Sxi :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/DMRG/AKLT/docs/Matrix/Matrix.html">Matrix</A>& Sxi  (int i <A HREF="/home/regnault/development/DMRG/AKLT/docs/Matrix/Matrix.html">Matrix</A>& M )<BR><BR>
<u>description:</u>return matrix representation of Sx 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = operator position 
<BR>M = matrix where representation has to be stored 
<BR><BR><BR>
<u>return value:</u> corresponding matrix 
<BR>
<BR><BR><BR><H3>Syi :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/DMRG/AKLT/docs/Matrix/Matrix.html">Matrix</A>& Syi  (int i <A HREF="/home/regnault/development/DMRG/AKLT/docs/Matrix/Matrix.html">Matrix</A>& M )<BR><BR>
<u>description:</u>return matrix representation of i * Sy 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = operator position 
<BR>M = matrix where representation has to be stored 
<BR><BR><BR>
<u>return value:</u> corresponding matrix 
<BR>
<BR><BR><BR><H3>Szi :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/DMRG/AKLT/docs/Matrix/Matrix.html">Matrix</A>& Szi  (int i <A HREF="/home/regnault/development/DMRG/AKLT/docs/Matrix/Matrix.html">Matrix</A>& M )<BR><BR>
<u>description:</u>return matrix representation of Sz 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = operator position 
<BR>M = matrix where representation has to be stored 
<BR><BR><BR>
<u>return value:</u> corresponding matrix 
<BR>
<BR><BR><BR><H3>Pij :</H3>
<u>prototype:</u>     int Pij  (int i int j int state )<BR><BR>
<u>description:</u>return index of resulting state from application of P_ij operator on a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = first position 
<BR>j = second position 
<BR>state = index of the state to be applied on P_ij operator 
<BR><BR><BR>
<u>return value:</u> index of resulting state 
<BR>
<BR><BR><BR><H3>SziSzj :</H3>
<u>prototype:</u>     double SziSzj  (int i int j int state )<BR><BR>
<u>description:</u>return eigenvalue of Sz_i Sz_j associated to a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = first position 
<BR>j = second position 
<BR>state = index of the state to consider 
<BR><BR><BR>
<u>return value:</u> corresponding eigenvalue 
<BR>
<BR><BR><BR><H3>SmiSpj :</H3>
<u>prototype:</u>     int SmiSpj  (int i int j int state double& coefficient )<BR><BR>
<u>description:</u>return index of resulting state from application of S-_i S+_j operator on a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>i = position of S- operator 
<BR>j = position of S+ operator 
<BR>state = index of the state to be applied on S-_i S+_j operator 
<BR>coefficient = reference on double where numerical coefficient has to be stored 
<BR><BR><BR>
<u>return value:</u> index of resulting state 
<BR>
<BR><BR><BR><H3>ExtractSubspace :</H3>
<u>prototype:</u>     <A HREF="/home/regnault/development/DMRG/AKLT/docs/HilbertSpace/AbstractHilbertSpace.html">AbstractHilbertSpace</A>* ExtractSubspace  (<A HREF="/home/regnault/development/DMRG/AKLT/docs/QuantumNumber/AbstractQuantumNumber.html">AbstractQuantumNumber</A>& q <A HREF="/home/regnault/development/DMRG/AKLT/docs/HilbertSpace/SubspaceSpaceConverter.html">SubspaceSpaceConverter</A>& converter )<BR><BR>
<u>description:</u>extract subspace with a fixed quantum number 
<BR><BR><BR>
<u>input parameters:</u>
<BR>q = quantum number value 
<BR>converter = reference on subspace-space converter to use 
<BR><BR><BR>
<u>return value:</u> pointer to the new subspace 
<BR>
<BR><BR><BR><H3>FindStateIndex :</H3>
<u>prototype:</u>     int FindStateIndex  (unsigned long state )<BR><BR>
<u>description:</u>find state index 
<BR><BR><BR>
<u>input parameters:</u>
<BR>state = state description 
<BR><BR><BR>
<u>return value:</u> corresponding index 
<BR>
<BR><BR><BR><H3>PrintState :</H3>
<u>prototype:</u>     ostream& PrintState  (ostream& Str int state )<BR><BR>
<u>description:</u>print a given State 
<BR><BR><BR>
<u>input parameters:</u>
<BR>Str = reference on current output stream  
<BR>state = ID of the state to print 
<BR><BR><BR>
<u>return value:</u> reference on current output stream  
<BR>
<BR><BR><BR>	Back to <A HREF="/home/regnault/development/DMRG/AKLT/docs/index.html">index</A>. 

  </body>
</html>
