<html>
  <head>
    <title>ParticleOnTorusWithSpin</title>
  </head>

  <body>
    <H1><DIV align=center>Class : ParticleOnTorusWithSpin</DIV></H1>

<DIV ALIGN="CENTER">class deriving from <A HREF="/home/regnault/development/Physics/DiagHam/docs/HilbertSpace/AbstractHilbertSpace.html">AbstractHilbertSpace</A></DIV><BR>
<H3>~ParticleOnTorusWithSpin :</H3>
<u>prototype:</u>     <i>virtual</i> ~ParticleOnTorusWithSpin  ()<BR><BR>
<u>description:</u>virtual destructor 
<BR>
<BR><BR><BR><H3>GetParticleStatistic :</H3>
<u>prototype:</u>     <i>virtual</i> int GetParticleStatistic  ()<BR><BR>
<u>description:</u>get the particle statistic  
<BR><BR><BR>
<u>input parameters:</u>
<BR><BR><BR>
<u>return value:</u> particle statistic 
<BR>
<BR><BR><BR><H3>SumAudAu :</H3>
<u>prototype:</u>     <i>virtual</i> int SumAudAu  (int , double& coefficient )<BR><BR>
<u>description:</u>apply sum_m au^+_m au_m operator to a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>SumAddAd :</H3>
<u>prototype:</u>     <i>virtual</i> int SumAddAd  (int , double& coefficient )<BR><BR>
<u>description:</u>apply sum_m ad^+_m ad_m operator to a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AudAu :</H3>
<u>prototype:</u>     <i>virtual</i> int AudAu  (int , int , double& coefficient )<BR><BR>
<u>description:</u>apply au^+_m au_m operator to a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m = index for density operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AddAd :</H3>
<u>prototype:</u>     <i>virtual</i> int AddAd  (int , int , double& coefficient )<BR><BR>
<u>description:</u>apply ad^+_m ad_m operator to a given state 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m = index for density operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AudAudAuAu :</H3>
<u>prototype:</u>     <i>virtual</i> int AudAudAuAu  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply au^+_m1 au^+_m2 au_n1 au_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AddAddAdAd :</H3>
<u>prototype:</u>     <i>virtual</i> int AddAddAdAd  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply ad^+_m1 ad^+_m2 ad_n1 ad_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AddAddAuAu :</H3>
<u>prototype:</u>     <i>virtual</i> int AddAddAuAu  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply ad^+_m1 ad^+_m2 au_n1 au_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AudAudAdAd :</H3>
<u>prototype:</u>     <i>virtual</i> int AudAudAdAd  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply au^+_m1 au^+_m2 ad_n1 ad_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AudAudAuAd :</H3>
<u>prototype:</u>     <i>virtual</i> int AudAudAuAd  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply au^+_m1 au^+_m2 au_n1 ad_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AddAudAuAu :</H3>
<u>prototype:</u>     <i>virtual</i> int AddAudAuAu  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply ad^+_m1 au^+_m2 au_n1 au_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AddAddAdAu :</H3>
<u>prototype:</u>     <i>virtual</i> int AddAddAdAu  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply ad^+_m1 ad^+_m2 ad_n1 au_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AudAddAdAd :</H3>
<u>prototype:</u>     <i>virtual</i> int AudAddAdAd  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply au^+_m1 ad^+_m2 ad_n1 ad_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR><H3>AudAddAuAd :</H3>
<u>prototype:</u>     <i>virtual</i> int AudAddAuAd  (int , int , int , int , int , double& coefficient )<BR><BR>
<u>description:</u>apply au^+_m1 ad^+_m2 au_n1 ad_n2 operator to a given state (with m1+m2=n1+n2[MaxMomentum]) 
<BR><BR><BR>
<u>input parameters:</u>
<BR>index = index of the state on which the operator has to be applied 
<BR>m1 = first index for creation operator 
<BR>m2 = second index for creation operator 
<BR>n1 = first index for annihilation operator 
<BR>n2 = second index for annihilation operator 
<BR>coefficient = reference on the double where the multiplicative factor has to be stored 
<BR><BR><BR>
<u>return value:</u> index of the destination state  
<BR>
<BR><BR><BR>	Back to <A HREF="/home/regnault/development/Physics/DiagHam/docs/index.html">index</A>. 

  </body>
</html>
